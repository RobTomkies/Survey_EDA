% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data_type_detect.R
\name{data_type_detect}
\alias{data_type_detect}
\title{Data Type Detection and Forcing}
\usage{
data_type_detect(
  dataset,
  NLP_force = c(),
  ordinal_force = list(),
  nominal_force = c(),
  numeric_force = c(),
  alternate_nas = list(),
  preserve_nonconform = T
)
}
\arguments{
\item{dataset}{dataframe ; containing columns of each field and rows containing each record}

\item{NLP_force}{vector ; containing the names of the columns (as strings) or indexes of columns, or a combination,  that should be forced to natural language data type}

\item{ordinal_force}{list ; containing vectors for each column you wished forced to ordinal data type. The first element of each vector should be the name/index of the column you wish to force, followed by levels of the ordinal in order you wish them to be handles.}

\item{nominal_force}{vector ; containing the names of the columns (as strings) or indexes of columns, or a combination, that should be forced to nominal data type}

\item{numeric_force}{vector ; containing the names of the columns (as strings) or indexes of columns, or a combination, that should be forced to numeric data type.}

\item{alternate_nas}{list ; containing vectors for each column you wish to specify alternate/additional NA values for. The first element of each vector should be the name/index of the column you wish to force followed by the additional values in the column that should be considered as NA.}

\item{preserve_nonconform}{boolean ; value (T of F) on whether to separate and store data that does not conform to the detected/specified column type in an additional column}
}
\value{
A list containing:
\itemize{
\item data : The adjusted dataframe,
\item original_type: the original data type of the input dataframe
\item detected_type: the newly detected
}
}
\description{
This function receives a dataframe and outputs the dataframe with corrected
data types. The user can force columns to a certain data type via specifying
manually or allow a number of tests on data characteristics to automatically
detect the likely data type. In the common case for survey data where users
can select categories or enter free text and the data is included in one
column, the free text can be split out and preserved in additional columns
that will be added to the dataset.
}
\details{
Categorical data detection where unforced is split in to two approaches:

Where data is comprised of 20 or fewer records:
\itemize{
\item a value in the data is considered potentially nominal if over 10\% of values are that value
\item if over 80\% of records are made up of potentially categorical values we consider the field as nominal
}

Where data is comprised of 21 or more records:
\itemize{
\item a value in the data is considered potentially nominal if over 5\% of values are that value
\item if over 90\% of records are made up of potentially categorical values we consider the field as nominal
}

Of course if this is ineffective at detecting columns can be manually forced.

Numeric data detection where unforced is split in to two stages:
\itemize{
\item Firstly whether the data is numeric or not by seeing if over 60\% is numeric information.
\item If this is so and the data is less than 20 records long, if over 90\% of the data is integer based then overall we classify as integer
\item If numeric and over 20 records long, if over 95\% is integer then we classify as interger
\item If either of the last two steps fail but still over 60\% numeric information we classify as floating point numeric data
}

Of course if this is ineffective at detecting columns can be manually forced.

As ordinal data is almost impossible to automatically detect, this format is only implemented
when specified. Otherwise categorical data is detected and assumed as nominal.

Natural Language data (NLP ) is either forced manually or assumed to be the absence of either
categorical (nominal or ordinal), numeric (integer or floating point).
}
\examples{
data_type_detect(dataset = example_dataset,
                 NLP_force = c(1,2,3),
                 ordinal_force = list(c('col1', 'a','b','c'), c('col2', 2,3,4)),
                 nominal_force = c('col5','col7'),
                 numeric_force = c(14, 'colb'),
                 alternate_nas = list(c('col1', 'error')),
                 preserve_nonconform = T)

data_type_detect(example_dataset,
                 nominal_force = c('col5','col7'),
                 alternate_nas = list(c('col1', 'error')))
}
