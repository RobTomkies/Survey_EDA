}
#detect columns
if(length(columns_to_detect) >= 1){
#categorical first as stricter on classifying
cat_detect <- Nominal_Detect(columns_to_detect, dataset, preserve_nonconform = preserve_nonconform, force = F)
dataset <- cat_detect$data
cats_detected <- cat_detect$detected
columns_to_detect <- columns_to_detect[!(columns_to_detect %in% cats_detected)]
}
if(length(columns_to_detect) >= 1){
#numeric_data
numeric_detect <- Numeric_Type_Detect(columns_to_detect, dataset, preserve_nonconform = preserve_nonconform, force = F)
dataset <- numeric_detect$data
double_detected <- numeric_detect$floats
ints_detected <- numeric_detect$integers
rm(numeric_detect)
columns_to_detect <- columns_to_detect[!(columns_to_detect %in% c(double_detected, ints_detected))]
}
if(length(columns_to_detect) >= 1){
#remainder columns set to NLP
dataset <- NLP_Convert(columns_to_detect, dataset)
}
NLP_final <- names(dataset)[c(columns_to_detect, NLP_force)]
Integer_final <- names(dataset)[c(ints_forced, ints_detected)]
Floating_final <- names(dataset)[c(double_forced, double_detected)]
Nominal_final <- names(dataset)[c(cats_detected, nominal_force)]
Ordinal_final <- c()
if(length(ordinal_force)>= 1){
Ordinal_final <- names(dataset)[c(ordinal_force)]
}
converted_names<- original_names
converted_names[original_names %in% NLP_final] <- 'NLP'
converted_names[original_names %in% Integer_final] <-'Integer'
converted_names[original_names %in% Floating_final] <- 'Float'
converted_names[original_names %in% Nominal_final] <-'Nominal'
converted_names[original_names %in% Ordinal_final] <-'Ordinal'
output <- list(data = dataset,
original_type = data.frame(data_field = original_names, data_type = original_type),
converted_type = data.frame(data_field = original_names, data_type = converted_names))
}
z <- data_type_detect(trial_data)
z
rm(list = ls())
pacman::p_load(devtools, roxygen2, knitr, testthat)
load_all()
#trial_dataframe <- data.frame(x = c(1,2,3,4,5,6,7,8), y = c(2,3,4,6,7,8,9,5), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7),actual_int = c('1','2','3','4','5','6','7','8'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est'))
trial_dataframe <- data.frame(ordinal_level_uno = c(1,2,3,2,3,1,'hello', 'dragon',1,2,1), x = c(1,2,3,4,3,1,2,2,2,1,4), y = c(2,3,4,6,7,8,9,5,8,4,1), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7,3.4,4.3,2.1),actual_int = c('1','2','3','4','5','6','7','8', '10','9','99'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est', 'hero', 'ever', 'like'))
test()
#trial_dataframe <- data.frame(x = c(1,2,3,4,5,6,7,8), y = c(2,3,4,6,7,8,9,5), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7),actual_int = c('1','2','3','4','5','6','7','8'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est'))
trial_dataframe <- data.frame(ordinal_level_uno = c(1,2,3,2,3,1,'hello', 'dragon',1,2,1), x = c(1,2,3,4,3,1,2,2,2,1,4), y = c(2,3,4,6,7,8,9,5,8,4,1), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7,3.4,4.3,2.1),actual_int = c('1','2','3','4','5','6','7','8', '10','9','99'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est', 'hero', 'ever', 'like'))
rm(list = ls())
#trial_dataframe <- data.frame(x = c(1,2,3,4,5,6,7,8), y = c(2,3,4,6,7,8,9,5), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7),actual_int = c('1','2','3','4','5','6','7','8'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est'))
trial_dataframe <- data.frame(ordinal_level_uno = c(1,2,3,2,3,1,'hello', 'dragon',1,2,1), x = c(1,2,3,4,3,1,2,2,2,1,4), y = c(2,3,4,6,7,8,9,5,8,4,1), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7,3.4,4.3,2.1),actual_int = c('1','2','3','4','5','6','7','8', '10','9','99'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est', 'hero', 'ever', 'like'))
load_all()
test()
#trial_dataframe <- data.frame(x = c(1,2,3,4,5,6,7,8), y = c(2,3,4,6,7,8,9,5), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7),actual_int = c('1','2','3','4','5','6','7','8'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est'))
test_that("data input error catching", {
expect_error(data_type_detect(2), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect(c(1,2,3,4,5,6)), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect('hello'), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect(matrix(data = c(1,2,3,45), nrow = 2)), "Please pass a dataframe type structure to the function")
expect_silent(data_type_detect(trial_dataframe))
})
test_that("data type forcing error, force type warnings working",{
expect_warning(column_recog_vector('integer', c(1.1, 2, 3, 4),  trial_dataframe), 'Float type number provided for  integer  forcing so converted to integer')
expect_warning(column_recog_vector('string', c(1.1, 2, 3, 4),  trial_dataframe), 'Float type number provided for  string  forcing so converted to integer')
})
test_that("data type forcing, repeat column requests adjusted for",{
expect_warning(column_recog_vector('integer', c(1,1, 2, 3, 4),  trial_dataframe), 'type 1: duplicated found in forcing columns - simplified so only one present')
expect_warning(column_recog_vector('integer', c('x','x', 'y'),  trial_dataframe), 'type 1: duplicated found in forcing columns - simplified so only one present')
})
test_that("data type forcing error, integer index checks", {
expect_silent(column_recog_vector('integer', c(1, 2, 3, 4),  trial_dataframe))
expect_identical(column_recog_vector('integer', c(1, 2, 3, 4),  trial_dataframe), as.integer(c(1,2,3,4)))
w <- capture_warnings(column_recog_vector('integer', c('x',1),  trial_dataframe))
expect_identical(w[3], "type 2: duplicate columns for forcing found - simplified to only one\n")
})
w
test_that("data type forcing error, integer index checks", {
expect_silent(column_recog_vector('integer', c(1, 2, 3, 4),  trial_dataframe))
expect_identical(column_recog_vector('integer', c(1, 2, 3, 4),  trial_dataframe), as.integer(c(1,2,3,4)))
w <- capture_warnings(column_recog_vector('integer', c('x',1),  trial_dataframe))
expect_identical(w[3], "type 2: duplicate columns for forcing found - simplified to only one\n")
})
column_recog_vector('integer', c('x',1),  trial_dataframe)
trial_dataframe
rm(list = ls())
#trial_dataframe <- data.frame(x = c(1,2,3,4,5,6,7,8), y = c(2,3,4,6,7,8,9,5), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7),actual_int = c('1','2','3','4','5','6','7','8'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est'))
trial_dataframe <- data.frame(x = c(1,2,3,4,3,1,2,2,2,1,4), y = c(2,3,4,6,7,8,9,5,8,4,1), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7,3.4,4.3,2.1),actual_int = c('1','2','3','4','5','6','7','8', '10','9','99'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est', 'hero', 'ever', 'like'), ordinal_level_uno = c(1,2,3,2,3,1,'hello', 'dragon',1,2,1))
load_all()
test()
#trial_dataframe <- data.frame(x = c(1,2,3,4,5,6,7,8), y = c(2,3,4,6,7,8,9,5), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7),actual_int = c('1','2','3','4','5','6','7','8'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est'))
test_that("data input error catching", {
expect_error(data_type_detect(2), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect(c(1,2,3,4,5,6)), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect('hello'), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect(matrix(data = c(1,2,3,45), nrow = 2)), "Please pass a dataframe type structure to the function")
expect_silent(data_type_detect(trial_dataframe))
})
test_that("data type forcing error, force type warnings working",{
expect_warning(column_recog_vector('integer', c(1.1, 2, 3, 4),  trial_dataframe), 'Float type number provided for  integer  forcing so converted to integer')
expect_warning(column_recog_vector('string', c(1.1, 2, 3, 4),  trial_dataframe), 'Float type number provided for  string  forcing so converted to integer')
})
test_that("data type forcing, repeat column requests adjusted for",{
expect_warning(column_recog_vector('integer', c(1,1, 2, 3, 4),  trial_dataframe), 'type 1: duplicated found in forcing columns - simplified so only one present')
expect_warning(column_recog_vector('integer', c('x','x', 'y'),  trial_dataframe), 'type 1: duplicated found in forcing columns - simplified so only one present')
})
test_that("data type forcing error, integer index checks", {
expect_silent(column_recog_vector('integer', c(1, 2, 3, 4),  trial_dataframe))
expect_identical(column_recog_vector('integer', c(1, 2, 3, 4),  trial_dataframe), as.integer(c(1,2,3,4)))
w <- capture_warnings(column_recog_vector('integer', c('x',1),  trial_dataframe))
expect_identical(w[3], "type 2: duplicate columns for forcing found - simplified to only one\n")
})
test_that("data type forcing error, float index checks",{
expect_warning(column_recog_vector('integer', c(1.1, 2, 3, 4),  trial_dataframe), 'Float type number provided for  integer  forcing so converted to integer')
expect_identical(suppressWarnings(column_recog_vector('integer', c(1.1, 2, 3, 4),  trial_dataframe)), as.integer(c(1,2,3,4)))
})
test_that("data type forcing error, logical index checks",{
expect_silent(column_recog_vector('integer', c(T, T, T, F, F),  trial_dataframe))
expect_identical(column_recog_vector('integer', c(T, T, T, F, F),  trial_dataframe), as.integer(c(1,2,3)))
expect_error(column_recog_vector('integer', c(T, T, F, F),  trial_dataframe), 'logical forcing vector for  integer  does not match the length of dataset columns please reconsider')
})
test_that("data type forcing error, logical index checks",{
expect_silent(column_recog_vector('integer', rep(T, 11),  trial_dataframe))
expect_identical(column_recog_vector('integer', c(T, T, T, F, F),  trial_dataframe), as.integer(c(1,2,3)))
expect_error(column_recog_vector('integer', c(T, T, F, F),  trial_dataframe), 'logical forcing vector for  integer  does not match the length of dataset columns please reconsider')
})
column_recog_vector('integer', rep(T, 11),  trial_dataframe)
test_that("data type forcing error, logical index checks",{
expect_silent(column_recog_vector('integer', rep(T, 6),  trial_dataframe))
expect_identical(column_recog_vector('integer', c(T, T, T, F, F),  trial_dataframe), as.integer(c(1,2,3)))
expect_error(column_recog_vector('integer', c(T, T, F, F),  trial_dataframe), 'logical forcing vector for  integer  does not match the length of dataset columns please reconsider')
})
column_recog_vector('integer', rep(T, 6),  trial_dataframe)
column_recog_vector('integer', c(T, T, T, F, F),  trial_dataframe), as.integer(c(1,2,3))
column_recog_vector('integer', c(T, T, T, F, F),  trial_dataframe)
column_recog_vector('integer', c(T, T, T, F, F,F),  trial_dataframe)
test_that("data type forcing error, logical index checks",{
expect_silent(column_recog_vector('integer', rep(T, 6),  trial_dataframe))
expect_identical(column_recog_vector('integer', c(T, T, T, F, F,F),  trial_dataframe), as.integer(c(1,2,3)))
expect_error(column_recog_vector('integer', c(T, T, F, F),  trial_dataframe), 'logical forcing vector for  integer  does not match the length of dataset columns please reconsider')
})
#column_recog_vector('integer', c('1.2', '2', '3','4.4', 'words'),  trial_dataframe)
test_that("data type forcing error, string index checks",{
expect_silent(column_recog_vector('integer', c('x', 'y', 'doubls'),  trial_dataframe))
expect_identical(column_recog_vector('integer', c('x', 'y', 'doubls'),  trial_dataframe), as.integer(c(1,2,3)))
w <- capture_warnings(column_recog_vector('integer', c('1.2', '2', '3','4.4', 'words'),  trial_dataframe))
expect_identical(w[2],  "Integer names  2, 3  not found for  integer  forcing but successfully coerced to integer index\n")
expect_identical(w[3],  "Numeric names  1.2, 4.4  not found for  integer  forcing but successfully coerced to integer index\n")
})
load_all()
test()
?pander
??pander
library(pander)
?pander
print(pander(trial_dataframe))
pander(trial_dataframe)
print(pander(trial_dataframe))
print.data_detected <- function(x){
data <- x$data
pander(head(data))
}
summary.data_detected <- function(x){
data <- x$original_type
data <- cbind(data, converted_type = x$converted_type[,2])
pander(data)
}
# trial_data <- trial_dataframe
# xb <- c('x', 'ordinal_level_uno' ) #, c('doubls', 2,5,6)
z <- data_type_detect(trial_data)
View(trial_dataframe)
trial_data <- trial_dataframe
# xb <- c('x', 'ordinal_level_uno' ) #, c('doubls', 2,5,6)
z <- data_type_detect(trial_data)
print(z)
data_type_detect <- function(dataset,
NLP_force = c(),
ordinal_force = list(), #list(c(‘colname’, ‘level1’, ‘level2’))
nominal_force = c(),
numeric_force = c(),
alternate_nas = list(), #list(c(“colname1”, 0, 99),c(“colname2”, “hold”))
preserve_nonconform = T){
#check input format
if(!is.data.frame(dataset)){stop('Please pass a dataframe type structure to the function')}
#initiate_vectors
#determine original data type
original_typeb <- sapply(dataset, class)
original_names <- names(dataset)
original_type <- original_typeb
original_type[original_typeb == "factor"] <- 'Nominal'
original_type[original_typeb == "logical"] <- 'Nominal'
original_type[original_typeb == "numeric"] <- 'Float'
original_type[original_typeb == "integer"] <- 'Integer'
original_type[original_typeb == "character"] <- 'NLP'
#remove alternate NAs
dataset <- Alternate_NA_Remove(alternate_nas, dataset)
#determine forced columns
if(length(NLP_force) >= 1){
NLP_force <- column_recog_vector('NLP', NLP_force, dataset)
}
if(length(nominal_force) >= 1){
nominal_force <- column_recog_vector('nominal', nominal_force, dataset)
}
if(length(numeric_force) >= 1){
numeric_force <- column_recog_vector('numeric', numeric_force, dataset)
}
if(length(ordinal_force) >= 1){
ordinal_force <- column_recog_list('ordinal', ordinal_force, dataset)
}
if(length(ordinal_force) >= 1){
forced_columns <- c(NLP_force, nominal_force, numeric_force, ordinal_force[[1]])
}
else{
forced_columns <- c(NLP_force, nominal_force, numeric_force)
}
if(any(duplicated(forced_columns))){
stop(paste('Column', forced_columns[duplicated(forced_columns)], 'has been forced to multiple data types, please reconsider'))
}
#auto detect columns are the remaining ones
if(length(forced_columns) >= 1){
columns_to_detect <- (1:ncol(dataset))[-forced_columns]
}
else{
columns_to_detect <- (1:ncol(dataset))
}
#force columns
#!TODO repeats the column recog function - look at streamlining
if(length(ordinal_force) >= 1){
dataset <- Ordinal_Force(ordinal_force, dataset, preserve_nonconform = preserve_nonconform)
}
#keep records of int vs double
double_forced <- ints_forced <- c()
if(length(numeric_force) >= 1){
numeric_forced <- Numeric_Type_Detect(numeric_force, dataset, preserve_nonconform = preserve_nonconform, force = T)
dataset <- numeric_forced$data
double_forced <- numeric_forced$floats
ints_forced <- numeric_forced$integers
rm(numeric_forced)
}
if(length(nominal_force) >= 1){
dataset <- Nominal_Detect(nominal_force, dataset, preserve_nonconform = preserve_nonconform, force = T)
}
if(length(NLP_force) >= 1){
dataset <- NLP_Convert(NLP_force, dataset)
}
#detect columns
if(length(columns_to_detect) >= 1){
#categorical first as stricter on classifying
cat_detect <- Nominal_Detect(columns_to_detect, dataset, preserve_nonconform = preserve_nonconform, force = F)
dataset <- cat_detect$data
cats_detected <- cat_detect$detected
columns_to_detect <- columns_to_detect[!(columns_to_detect %in% cats_detected)]
}
if(length(columns_to_detect) >= 1){
#numeric_data
numeric_detect <- Numeric_Type_Detect(columns_to_detect, dataset, preserve_nonconform = preserve_nonconform, force = F)
dataset <- numeric_detect$data
double_detected <- numeric_detect$floats
ints_detected <- numeric_detect$integers
rm(numeric_detect)
columns_to_detect <- columns_to_detect[!(columns_to_detect %in% c(double_detected, ints_detected))]
}
if(length(columns_to_detect) >= 1){
#remainder columns set to NLP
dataset <- NLP_Convert(columns_to_detect, dataset)
}
NLP_final <- names(dataset)[c(columns_to_detect, NLP_force)]
Integer_final <- names(dataset)[c(ints_forced, ints_detected)]
Floating_final <- names(dataset)[c(double_forced, double_detected)]
Nominal_final <- names(dataset)[c(cats_detected, nominal_force)]
Ordinal_final <- c()
if(length(ordinal_force)>= 1){
Ordinal_final <- names(dataset)[c(ordinal_force)]
}
converted_names<- original_names
converted_names[original_names %in% NLP_final] <- 'NLP'
converted_names[original_names %in% Integer_final] <-'Integer'
converted_names[original_names %in% Floating_final] <- 'Float'
converted_names[original_names %in% Nominal_final] <-'Nominal'
converted_names[original_names %in% Ordinal_final] <-'Ordinal'
output <- list(data = dataset,
original_type = data.frame(data_field = original_names, data_type = original_type),
converted_type = data.frame(data_field = original_names, data_type = converted_names))
class(output) <- "data_detected"
}
trial_data <- trial_dataframe
# xb <- c('x', 'ordinal_level_uno' ) #, c('doubls', 2,5,6)
z <- data_type_detect(trial_data)
print(z)
summary(z)
print.data_detected <- function(x){
data <- x$data
pander(head(data))
}
summary.data_detected <- function(x){
data <- x$original_type
data <- cbind(data, converted_type = x$converted_type[,2])
pander(data)
}
# xb <- c('x', 'ordinal_level_uno' ) #, c('doubls', 2,5,6)
z <- data_type_detect(trial_data)
z
data_type_detect <- function(dataset,
NLP_force = c(),
ordinal_force = list(), #list(c(‘colname’, ‘level1’, ‘level2’))
nominal_force = c(),
numeric_force = c(),
alternate_nas = list(), #list(c(“colname1”, 0, 99),c(“colname2”, “hold”))
preserve_nonconform = T){
#check input format
if(!is.data.frame(dataset)){stop('Please pass a dataframe type structure to the function')}
#initiate_vectors
#determine original data type
original_typeb <- sapply(dataset, class)
original_names <- names(dataset)
original_type <- original_typeb
original_type[original_typeb == "factor"] <- 'Nominal'
original_type[original_typeb == "logical"] <- 'Nominal'
original_type[original_typeb == "numeric"] <- 'Float'
original_type[original_typeb == "integer"] <- 'Integer'
original_type[original_typeb == "character"] <- 'NLP'
#remove alternate NAs
dataset <- Alternate_NA_Remove(alternate_nas, dataset)
#determine forced columns
if(length(NLP_force) >= 1){
NLP_force <- column_recog_vector('NLP', NLP_force, dataset)
}
if(length(nominal_force) >= 1){
nominal_force <- column_recog_vector('nominal', nominal_force, dataset)
}
if(length(numeric_force) >= 1){
numeric_force <- column_recog_vector('numeric', numeric_force, dataset)
}
if(length(ordinal_force) >= 1){
ordinal_force <- column_recog_list('ordinal', ordinal_force, dataset)
}
if(length(ordinal_force) >= 1){
forced_columns <- c(NLP_force, nominal_force, numeric_force, ordinal_force[[1]])
}
else{
forced_columns <- c(NLP_force, nominal_force, numeric_force)
}
if(any(duplicated(forced_columns))){
stop(paste('Column', forced_columns[duplicated(forced_columns)], 'has been forced to multiple data types, please reconsider'))
}
#auto detect columns are the remaining ones
if(length(forced_columns) >= 1){
columns_to_detect <- (1:ncol(dataset))[-forced_columns]
}
else{
columns_to_detect <- (1:ncol(dataset))
}
#force columns
#!TODO repeats the column recog function - look at streamlining
if(length(ordinal_force) >= 1){
dataset <- Ordinal_Force(ordinal_force, dataset, preserve_nonconform = preserve_nonconform)
}
#keep records of int vs double
double_forced <- ints_forced <- c()
if(length(numeric_force) >= 1){
numeric_forced <- Numeric_Type_Detect(numeric_force, dataset, preserve_nonconform = preserve_nonconform, force = T)
dataset <- numeric_forced$data
double_forced <- numeric_forced$floats
ints_forced <- numeric_forced$integers
rm(numeric_forced)
}
if(length(nominal_force) >= 1){
dataset <- Nominal_Detect(nominal_force, dataset, preserve_nonconform = preserve_nonconform, force = T)
}
if(length(NLP_force) >= 1){
dataset <- NLP_Convert(NLP_force, dataset)
}
#detect columns
if(length(columns_to_detect) >= 1){
#categorical first as stricter on classifying
cat_detect <- Nominal_Detect(columns_to_detect, dataset, preserve_nonconform = preserve_nonconform, force = F)
dataset <- cat_detect$data
cats_detected <- cat_detect$detected
columns_to_detect <- columns_to_detect[!(columns_to_detect %in% cats_detected)]
}
if(length(columns_to_detect) >= 1){
#numeric_data
numeric_detect <- Numeric_Type_Detect(columns_to_detect, dataset, preserve_nonconform = preserve_nonconform, force = F)
dataset <- numeric_detect$data
double_detected <- numeric_detect$floats
ints_detected <- numeric_detect$integers
rm(numeric_detect)
columns_to_detect <- columns_to_detect[!(columns_to_detect %in% c(double_detected, ints_detected))]
}
if(length(columns_to_detect) >= 1){
#remainder columns set to NLP
dataset <- NLP_Convert(columns_to_detect, dataset)
}
NLP_final <- names(dataset)[c(columns_to_detect, NLP_force)]
Integer_final <- names(dataset)[c(ints_forced, ints_detected)]
Floating_final <- names(dataset)[c(double_forced, double_detected)]
Nominal_final <- names(dataset)[c(cats_detected, nominal_force)]
Ordinal_final <- c()
if(length(ordinal_force)>= 1){
Ordinal_final <- names(dataset)[c(ordinal_force)]
}
converted_names<- original_names
converted_names[original_names %in% NLP_final] <- 'NLP'
converted_names[original_names %in% Integer_final] <-'Integer'
converted_names[original_names %in% Floating_final] <- 'Float'
converted_names[original_names %in% Nominal_final] <-'Nominal'
converted_names[original_names %in% Ordinal_final] <-'Ordinal'
output <- list(data = dataset,
original_type = data.frame(data_field = original_names, data_type = original_type),
converted_type = data.frame(data_field = original_names, data_type = converted_names))
class(output) <- "data_detected"
return(output)
}
# xb <- c('x', 'ordinal_level_uno' ) #, c('doubls', 2,5,6)
z <- data_type_detect(trial_data)
z
print(z)
summary(z)
summary.data_detected <- function(x){
data <- x$original_type
data <- cbind(original_type = data[,2], converted_type = x$converted_type[,2])
pander(data)
}
summary(z)
summary.data_detected <- function(x){
data <- x$original_type
data <- cbind(data_field = data[,2], original_type = data[,2], converted_type = x$converted_type[,2])
pander(data)
}
print.data_detected <- function(x){
data <- x$data
pander(head(data))
}
summary(z)
summary.data_detected <- function(x){
data <- x$original_type
data <- cbind(data_field = data[,1], original_type = data[,2], converted_type = x$converted_type[,2])
pander(data)
}
summary(z)
print(z)
use_mit_license("Robert J Tomkies")
load_all()
pacman::p_load(roxygen2, devtools, knitr, testthat)
load_all()
test()
load_all()
test_that("data input error catching", {
expect_error(data_type_detect(2), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect(c(1,2,3,4,5,6)), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect('hello'), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect(matrix(data = c(1,2,3,45), nrow = 2)), "Please pass a dataframe type structure to the function")
expect_silent(data_type_detect(trial_dataframe))
})
trial_dataframe <- data.frame(x = c(1,2,3,4,3,1,2,2,2,1,4), y = c(2,3,4,6,7,8,9,5,8,4,1), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7,3.4,4.3,2.1),actual_int = c('1','2','3','4','5','6','7','8', '10','9','99'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est', 'hero', 'ever', 'like'), ordinal_level_uno = c(1,2,3,2,3,1,'hello', 'dragon',1,2,1))
#logrelative error
LRE <- function(x,c){
if(c==0){return(round(-log(abs(x), base = 10)))}
else{return(round(-log((abs(x-c)/c) , base = 10)))}
}
test_that("data input error catching", {
expect_error(data_type_detect(2), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect(c(1,2,3,4,5,6)), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect('hello'), "Please pass a dataframe type structure to the function")
expect_error(data_type_detect(matrix(data = c(1,2,3,45), nrow = 2)), "Please pass a dataframe type structure to the function")
expect_silent(data_type_detect(trial_dataframe))
})
load_all()
test()
basic_test_data <- data.frame(x = c(1,2,3,4,3,1,2,2,2,1,4), y = c(2,3,4,6,7,8,9,5,8,4,1), doubls = c(1.1,2,3,4.1,5.2,4.6,7.1,9.7,3.4,4.3,2.1),actual_int = c('1','2','3','4','5','6','7','8', '10','9','99'),words = c('hello', 'my', 'name', 'is', 'rob', 'the', 'great', 'est', 'hero', 'ever', 'like'), ordinal_level_uno = c(1,2,3,2,3,1,'hello', 'dragon',1,2,1))
devtools::use_data(basic_test_data)
pacman::p_load(devtools, roxygen2, knitr, testthat)
use_data(basic_test_data)
pacman::p_load(knitr, roxygen2, devtools, testthat)
load_all()
load_all()
test()
trial_dataframe <- data(basic_test_data)
trial_dataframe
trial_dataframe <- data('basic_test_data')
trial_dataframe
trial_dataframe <- data('basic_test_data')
basic_test_data
pacman::p_load(devtools, roxygen2, knitr, testthat)
load_all()
test()
load_all()
?data_type_detect
document()
warnings()
?data_type_detect
document()
?data_type_detect
document()
?data_type_detect
document()
?data_type_detect
document()
?data_type_detect
use_vignette("data_type_detect")
load_all()
summary(data_type_detect(basic_test_data))
data_type_detect(basic_test_data)
summary(data_type_detect(basic_test_data))
summary.data_detected <- function(x){
data <- x$original_type
data <- cbind(data_field = data[,1], original_type = data[,2], converted_type = x$converted_type[,2])
pander(data)
}
summary(data_type_detect(basic_test_data))
load_all()
