a <- x$converted_type$data_field[x$converted_type$data_type == 'Nominal']
b <- x$converted_type$data_field[x$converted_type$data_type == 'Float']
c <- x$converted_type$data_field[x$converted_type$data_type == 'Integer']
rbind(a,b,c)
a <- x$converted_type$data_field[x$converted_type$data_type == 'Nominal']
b <- x$converted_type$data_field[x$converted_type$data_type == 'Float']
c <- x$converted_type$data_field[x$converted_type$data_type == 'Integer']
a
b
c
rbind(a,b,c)
pander(rbind(a,b,c))
pander(cbind(a,b,c))
lapply(c(a, b, c), length)
a <- x$converted_type$data_field[x$converted_type$data_type == 'Nominal']
b <- x$converted_type$data_field[x$converted_type$data_type == 'Float']
c <- x$converted_type$data_field[x$converted_type$data_type == 'Integer']
apply(c(a, b, c), length)
papply(c(a, b, c), length)
sapply(c(a, b, c), length)
a <- x$converted_type$data_field[x$converted_type$data_type == 'Nominal']
b <- x$converted_type$data_field[x$converted_type$data_type == 'Float']
c <- x$converted_type$data_field[x$converted_type$data_type == 'Integer']
a
b
c
sapply(c(a, b, c), length)
length(c(a, b, c))
length(a, b, c)
lapply(c(a, b, c), length)
a
length(a)
lapply(c(a, b, c), length, simplify = FALSE)
sapply(c(a, b, c), length, simplify = FALSE)
sapply(c(a, b, c), length, USE.NAMES = FALSE)
sapply(list(a, b, c), length, USE.NAMES = FALSE)
sapply(list(a, b, c), length, USE.NAMES = T)
max(sapply(list(a, b, c), length))
data.frame(matrix(ncol = 5, nrow = ML))
ML <- 5
dttype_dataframe <- data.frame(matrix(ncol = 5, nrow = ML))
dttype_dataframe
ML <- 9
dttype_dataframe <- data.frame(matrix(ncol = 5, nrow = ML))
dttype_dataframe
a <- x$converted_type$data_field[x$converted_type$data_type == 'Nominal']
b <- x$converted_type$data_field[x$converted_type$data_type == 'Float']
c <- x$converted_type$data_field[x$converted_type$data_type == 'Integer']
length(a) <- length(b) <- length(c) <- 3
a
b
c
cbind(a,b,c)
pander(length(a, b, c))
pander(cbind(a,b,c))
is.na(x) <- ""
pander(x)
x
x <- cbind(a,b,c)
is.na(x) <- ""
pander(x)
x <- cbind(a,b,c)
x
is.na(x) <- ""
x
length(a) <- length(b) <- length(c) <- 3
x <- cbind(a,b,c)
x[is.na(x)] <- ""
x
pander(length(a, b, c))
pander(x)
a <- x$converted_type$data_field[x$converted_type$data_type == 'Nominal']
b <- x$converted_type$data_field[x$converted_type$data_type == 'Float']
c <- x$converted_type$data_field[x$converted_type$data_type == 'Integer']
z <- x$converted_type
View(z)
View(z)
x <- c(1,2,3,4,5,5,6,7,8,6,5,3,2,3,4,5,34)
y <- c(1,2,3,4,5,6,4,NA, 4,3,NA,4,5,6)
x <- c(1,2,3,4,5,5,6,7,8,6,5,3,2,3,4,5,34)
y <- c(1,2,3,4,5,6,4,NA, 4,3,NA,4,5,6)
z <- c('hello', 'my' , 'name', 'is', NA, 'ROB', NA, 'TREE')
a <- cbind(x,y,z)
a
sapply(a, function(x) sum(is.na(x))/length(x) )
sapply(a,2, function(x) sum(is.na(x))/length(x) )
sapply(a, function(x) sum(is.na(x))/length(x) )
sapply(a, function(x){return(sum(is.na(x))/length(x))} )
a
apply(a, 2,  function(x){return(sum(is.na(x))/length(x))} )
apply(a, 2,  function(x){return(sum(is.na(x))/length(x))})
x <- c(1,2,3,4,5,5,6,7,8,6,5,3,2,3,4,5,34)
y <- c(1,2,3,4,5,6,4,NA, 4,3,NA,4,5,6)
z <- c('hello', 'my' , 'name', 'is', NA, 'ROB', NA, 'TREE')
a <- cbind(x,y,z)
outvec <- apply(a, 2,  function(x){return(sum(is.na(x))/length(x))})
names(outvect)
outvec <- apply(a, 2,  function(x){return(sum(is.na(x))/length(x))})
names(outvect)
names(outvec)
complete <- names(outvec)[outvec == 0]
complete
under_10 <- names(outvec)[outvec <= 10 & !(names(outvec) %in% complete)]
under_10
z
outvec <- apply(a, 2,  function(x){return(sum(is.na(x))/length(x))})
outvec
x <- c(1,2,3,4,5,5,6,7,8,6,5,3,2,3,4,5,34)
y <- c(1,2,3,4,5,6,4,NA, 4,3,NA,4,5,6)
z <- c('hello', 'my' , 'name', 'is', NA, 'ROB', NA, 'TREE')
a <- cbind(x,y,z)
outvec <- apply(a, 2,  function(x){return(100*sum(is.na(x))/length(x))})
complete <- names(outvec)[outvec == 0]
under_10 <- names(outvec)[outvec <= 10 & !(names(outvec) %in% complete)]
under_10
outvec
under_10 <- names(outvec)[outvec <= 15 & !(names(outvec) %in% complete)]
under_10
data.frame(hell = c(car = 2, tree = 5), tonne = c(car = 4, tree = 5))
library(SurveyEdaPackage)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(SurveyEdaPackage)
summary(data_type_detect(basic_test_data))
print(data_type_detect(basic_test_data))
#' @export
Data_Describe <- function(dataset,
NLP_force = c(),
ordinal_force = list(), #list(c(‘colname’, ‘level1’, ‘level2’))
nominal_force = c(),
numeric_force = c(),
alternate_nas = list(), #list(c(“colname1”, 0, 99),c(“colname2”, “hold”))
preserve_nonconform = T,
remove_repeat = T){
#dataset dimensions
original_nrow <- nrow(dataset)
original_ncol <- ncol(dataset)
#detect and correct for data types, includes many error catching steps.
updated_data <- data_type_detect(dataset, NLP_force = NLP_force, ordinal_force = ordinal_force,
nominal_force = nominal_force, numeric_force = numeric_force,
numeric_force = numeric_force, alternate_nas = alternate_nas,
preserve_nonconform = preserve_nonconform)
#clean up original input data
rm(dataset)
#dimensions - new data
updated_ncol <- ncol(updated_data$data)
updated_nrow <- nrow(updated_data$data)
#memory
memory_size <- object.size(updated_data$data)
#datatypes
data_types <- cbind( updated_data$original_type['data_type'], updated_data$converted_type['data_type'])
names(data_types) <- c('original type', 'converted type')
#Data type lists
Ordinal_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Ordinal']
NLP_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'NLP']
Integer_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Integer']
Float_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Float']
Nominal_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Nominal']
ML <- max(sapply(list(Ordinal_type, NLP_type, Integer_type, Float_type, Nominal_type)), length)
#pad vectors
length(Ordinal_type) <- length(NLP_type)<- length(Integer_type)<- length(Float_type)<- length(Nominal_type) <- ML
#bind
dt_type_frame <- cbind(Ordinal_type, NLP_type, Integer_type, Float_type, Nominal_type)
#missingness
missingness_vector <- apply(updated_data$data, 2,  function(x){return(100*(sum(is.na(x)))/length(x))})
#names
complete <- names(missingness_vector)[missingness_vector == 0]
u10 <- names(missingness_vector)[missingness_vector <= 10 & missingness_vector > 0]
mt10_25 <- names(missingness_vector)[missingness_vector <= 25 & missingness_vector > 10]
mt25_u50 <- names(missingness_vector)[missingness_vector <= 50 & missingness_vector > 25]
mt50_u75 <- names(missingness_vector)[missingness_vector <= 75 & missingness_vector > 50]
mt75 <- names(missingness_vector)[missingness_vector > 75]
ML <- max(sapply(list(complete, u10,mt10_25, mt25_u50, mt50_u75, mt75)), length)
#pad vectors
length(complete) <- length(u10)<- length(mt10_25)<- length(mt25_u50)<- length(mt50_u75)<- length(mt75) <- ML
#bind
missingness_groups <- cbind(complete, u10,mt10_25, mt25_u50, mt50_u75, mt75)
output <- list(dimensions = data.frame(nrow = c(original = original_nrow , adjusted = updated_nrow),
ncol = c(original = original_ncol , adjusted = updated_ncol)),
memory_size = memory_size,
data_type_conversion = data_types,
data_type_names = dt_type_frame,
missingness_percentage = missingness_vector,
grouped_missingness = missingness_groups,
data = updated_data$data
)
class(output) <- 'data_describe'
return(output)
}
#' @export
print.data_describe <- function(x){
x <- unclass(x)
pander(x$dimensions)
output_dt_type <- x$data_type_names
output_dt_type[is.na(output_dt_type)] <- ""
pander(output_dt_type)
pander(x$grouped_missingness)
}
Data_Describe(basic_test_data)
#' @export
Data_Describe <- function(dataset,
NLP.force = c(),
ordinal.force = list(), #list(c(‘colname’, ‘level1’, ‘level2’))
nominal.force = c(),
numeric.force = c(),
alternate.nas = list(), #list(c(“colname1”, 0, 99),c(“colname2”, “hold”))
preserve.nonconform = T,
remove.repeat = T){
#dataset dimensions
original_nrow <- nrow(dataset)
original_ncol <- ncol(dataset)
#detect and correct for data types, includes many error catching steps.
updated_data <- data_type_detect(dataset, NLP_force = NLP.force, ordinal_force = ordinal.force,
nominal_force = nominal.force, numeric_force = numeric.force,
numeric_force = numeric.force, alternate_nas = alternate.nas,
preserve_nonconform = preserve.nonconform)
#clean up original input data
rm(dataset)
#dimensions - new data
updated_ncol <- ncol(updated_data$data)
updated_nrow <- nrow(updated_data$data)
#memory
memory_size <- object.size(updated_data$data)
#datatypes
data_types <- cbind( updated_data$original_type['data_type'], updated_data$converted_type['data_type'])
names(data_types) <- c('original type', 'converted type')
#Data type lists
Ordinal_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Ordinal']
NLP_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'NLP']
Integer_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Integer']
Float_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Float']
Nominal_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Nominal']
ML <- max(sapply(list(Ordinal_type, NLP_type, Integer_type, Float_type, Nominal_type)), length)
#pad vectors
length(Ordinal_type) <- length(NLP_type)<- length(Integer_type)<- length(Float_type)<- length(Nominal_type) <- ML
#bind
dt_type_frame <- cbind(Ordinal_type, NLP_type, Integer_type, Float_type, Nominal_type)
#missingness
missingness_vector <- apply(updated_data$data, 2,  function(x){return(100*(sum(is.na(x)))/length(x))})
#names
complete <- names(missingness_vector)[missingness_vector == 0]
u10 <- names(missingness_vector)[missingness_vector <= 10 & missingness_vector > 0]
mt10_25 <- names(missingness_vector)[missingness_vector <= 25 & missingness_vector > 10]
mt25_u50 <- names(missingness_vector)[missingness_vector <= 50 & missingness_vector > 25]
mt50_u75 <- names(missingness_vector)[missingness_vector <= 75 & missingness_vector > 50]
mt75 <- names(missingness_vector)[missingness_vector > 75]
ML <- max(sapply(list(complete, u10,mt10_25, mt25_u50, mt50_u75, mt75)), length)
#pad vectors
length(complete) <- length(u10)<- length(mt10_25)<- length(mt25_u50)<- length(mt50_u75)<- length(mt75) <- ML
#bind
missingness_groups <- cbind(complete, u10,mt10_25, mt25_u50, mt50_u75, mt75)
output <- list(dimensions = data.frame(nrow = c(original = original_nrow , adjusted = updated_nrow),
ncol = c(original = original_ncol , adjusted = updated_ncol)),
memory_size = memory_size,
data_type_conversion = data_types,
data_type_names = dt_type_frame,
missingness_percentage = missingness_vector,
grouped_missingness = missingness_groups,
data = updated_data$data
)
class(output) <- 'data_describe'
return(output)
}
#' @export
print.data_describe <- function(x){
x <- unclass(x)
pander(x$dimensions)
output_dt_type <- x$data_type_names
output_dt_type[is.na(output_dt_type)] <- ""
pander(output_dt_type)
pander(x$grouped_missingness)
}
Data_Describe(basic_test_data)
#' @export
Data_Describe <- function(dataset,
NLP.force = c(),
ordinal.force = list(), #list(c(‘colname’, ‘level1’, ‘level2’))
nominal.force = c(),
numeric.force = c(),
alternate.nas = list(), #list(c(“colname1”, 0, 99),c(“colname2”, “hold”))
preserve.nonconform = T,
remove.repeat = T){
#dataset dimensions
original_nrow <- nrow(dataset)
original_ncol <- ncol(dataset)
#detect and correct for data types, includes many error catching steps.
updated_data <- data_type_detect(dataset, NLP_force = NLP.force, ordinal_force = ordinal.force,
nominal_force = nominal.force, numeric_force = numeric.force,
alternate_nas = alternate.nas,
preserve_nonconform = preserve.nonconform)
#clean up original input data
rm(dataset)
#dimensions - new data
updated_ncol <- ncol(updated_data$data)
updated_nrow <- nrow(updated_data$data)
#memory
memory_size <- object.size(updated_data$data)
#datatypes
data_types <- cbind( updated_data$original_type['data_type'], updated_data$converted_type['data_type'])
names(data_types) <- c('original type', 'converted type')
#Data type lists
Ordinal_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Ordinal']
NLP_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'NLP']
Integer_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Integer']
Float_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Float']
Nominal_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Nominal']
ML <- max(sapply(list(Ordinal_type, NLP_type, Integer_type, Float_type, Nominal_type)), length)
#pad vectors
length(Ordinal_type) <- length(NLP_type)<- length(Integer_type)<- length(Float_type)<- length(Nominal_type) <- ML
#bind
dt_type_frame <- cbind(Ordinal_type, NLP_type, Integer_type, Float_type, Nominal_type)
#missingness
missingness_vector <- apply(updated_data$data, 2,  function(x){return(100*(sum(is.na(x)))/length(x))})
#names
complete <- names(missingness_vector)[missingness_vector == 0]
u10 <- names(missingness_vector)[missingness_vector <= 10 & missingness_vector > 0]
mt10_25 <- names(missingness_vector)[missingness_vector <= 25 & missingness_vector > 10]
mt25_u50 <- names(missingness_vector)[missingness_vector <= 50 & missingness_vector > 25]
mt50_u75 <- names(missingness_vector)[missingness_vector <= 75 & missingness_vector > 50]
mt75 <- names(missingness_vector)[missingness_vector > 75]
ML <- max(sapply(list(complete, u10,mt10_25, mt25_u50, mt50_u75, mt75)), length)
#pad vectors
length(complete) <- length(u10)<- length(mt10_25)<- length(mt25_u50)<- length(mt50_u75)<- length(mt75) <- ML
#bind
missingness_groups <- cbind(complete, u10,mt10_25, mt25_u50, mt50_u75, mt75)
output <- list(dimensions = data.frame(nrow = c(original = original_nrow , adjusted = updated_nrow),
ncol = c(original = original_ncol , adjusted = updated_ncol)),
memory_size = memory_size,
data_type_conversion = data_types,
data_type_names = dt_type_frame,
missingness_percentage = missingness_vector,
grouped_missingness = missingness_groups,
data = updated_data$data
)
class(output) <- 'data_describe'
return(output)
}
#' @export
print.data_describe <- function(x){
x <- unclass(x)
pander(x$dimensions)
output_dt_type <- x$data_type_names
output_dt_type[is.na(output_dt_type)] <- ""
pander(output_dt_type)
pander(x$grouped_missingness)
}
Data_Describe(basic_test_data)
#' @export
Data_Describe <- function(dataset,
NLP.force = c(),
ordinal.force = list(), #list(c(‘colname’, ‘level1’, ‘level2’))
nominal.force = c(),
numeric.force = c(),
alternate.nas = list(), #list(c(“colname1”, 0, 99),c(“colname2”, “hold”))
preserve.nonconform = T,
remove.repeat = T){
#dataset dimensions
original_nrow <- nrow(dataset)
original_ncol <- ncol(dataset)
#detect and correct for data types, includes many error catching steps.
updated_data <- data_type_detect(dataset, NLP_force = NLP.force, ordinal_force = ordinal.force,
nominal_force = nominal.force, numeric_force = numeric.force,
alternate_nas = alternate.nas,
preserve_nonconform = preserve.nonconform)
#clean up original input data
rm(dataset)
#dimensions - new data
updated_ncol <- ncol(updated_data$data)
updated_nrow <- nrow(updated_data$data)
#memory
memory_size <- object.size(updated_data$data)
#datatypes
data_types <- cbind( updated_data$original_type['data_type'], updated_data$converted_type['data_type'])
names(data_types) <- c('original type', 'converted type')
#Data type lists
Ordinal_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Ordinal']
NLP_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'NLP']
Integer_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Integer']
Float_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Float']
Nominal_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Nominal']
ML <- max(sapply(list(Ordinal_type, NLP_type, Integer_type, Float_type, Nominal_type)), length)
#pad vectors
length(Ordinal_type) <- length(NLP_type)<- length(Integer_type)<- length(Float_type)<- length(Nominal_type) <- ML
#bind
dt_type_frame <- cbind(Ordinal_type, NLP_type, Integer_type, Float_type, Nominal_type)
#missingness
missingness_vector <- apply(updated_data$data, 2,  function(x){return(100*(sum(is.na(x)))/length(x))})
#names
complete <- names(missingness_vector)[missingness_vector == 0]
u10 <- names(missingness_vector)[missingness_vector <= 10 & missingness_vector > 0]
mt10_25 <- names(missingness_vector)[missingness_vector <= 25 & missingness_vector > 10]
mt25_u50 <- names(missingness_vector)[missingness_vector <= 50 & missingness_vector > 25]
mt50_u75 <- names(missingness_vector)[missingness_vector <= 75 & missingness_vector > 50]
mt75 <- names(missingness_vector)[missingness_vector > 75]
ML <- max(sapply(list(complete, u10,mt10_25, mt25_u50, mt50_u75, mt75), length))
#pad vectors
length(complete) <- length(u10)<- length(mt10_25)<- length(mt25_u50)<- length(mt50_u75)<- length(mt75) <- ML
#bind
missingness_groups <- cbind(complete, u10,mt10_25, mt25_u50, mt50_u75, mt75)
output <- list(dimensions = data.frame(nrow = c(original = original_nrow , adjusted = updated_nrow),
ncol = c(original = original_ncol , adjusted = updated_ncol)),
memory_size = memory_size,
data_type_conversion = data_types,
data_type_names = dt_type_frame,
missingness_percentage = missingness_vector,
grouped_missingness = missingness_groups,
data = updated_data$data
)
class(output) <- 'data_describe'
return(output)
}
#' @export
print.data_describe <- function(x){
x <- unclass(x)
pander(x$dimensions)
output_dt_type <- x$data_type_names
output_dt_type[is.na(output_dt_type)] <- ""
pander(output_dt_type)
pander(x$grouped_missingness)
}
Data_Describe(basic_test_data)
#' @export
Data_Describe <- function(dataset,
NLP.force = c(),
ordinal.force = list(), #list(c(‘colname’, ‘level1’, ‘level2’))
nominal.force = c(),
numeric.force = c(),
alternate.nas = list(), #list(c(“colname1”, 0, 99),c(“colname2”, “hold”))
preserve.nonconform = T,
remove.repeat = T){
#dataset dimensions
original_nrow <- nrow(dataset)
original_ncol <- ncol(dataset)
#detect and correct for data types, includes many error catching steps.
updated_data <- data_type_detect(dataset, NLP_force = NLP.force, ordinal_force = ordinal.force,
nominal_force = nominal.force, numeric_force = numeric.force,
alternate_nas = alternate.nas,
preserve_nonconform = preserve.nonconform)
#clean up original input data
rm(dataset)
#dimensions - new data
updated_ncol <- ncol(updated_data$data)
updated_nrow <- nrow(updated_data$data)
#memory
memory_size <- object.size(updated_data$data)
#datatypes
data_types <- cbind( updated_data$original_type['data_type'], updated_data$converted_type['data_type'])
names(data_types) <- c('original type', 'converted type')
#Data type lists
Ordinal_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Ordinal']
NLP_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'NLP']
Integer_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Integer']
Float_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Float']
Nominal_type <- updated_data$converted_type$data_field[updated_data$converted_type$data_type == 'Nominal']
ML <- max(sapply(list(Ordinal_type, NLP_type, Integer_type, Float_type, Nominal_type), length))
#pad vectors
length(Ordinal_type) <- length(NLP_type)<- length(Integer_type)<- length(Float_type)<- length(Nominal_type) <- ML
#bind
dt_type_frame <- cbind(Ordinal_type, NLP_type, Integer_type, Float_type, Nominal_type)
#missingness
missingness_vector <- apply(updated_data$data, 2,  function(x){return(100*(sum(is.na(x)))/length(x))})
#names
complete <- names(missingness_vector)[missingness_vector == 0]
u10 <- names(missingness_vector)[missingness_vector <= 10 & missingness_vector > 0]
mt10_25 <- names(missingness_vector)[missingness_vector <= 25 & missingness_vector > 10]
mt25_u50 <- names(missingness_vector)[missingness_vector <= 50 & missingness_vector > 25]
mt50_u75 <- names(missingness_vector)[missingness_vector <= 75 & missingness_vector > 50]
mt75 <- names(missingness_vector)[missingness_vector > 75]
ML <- max(sapply(list(complete, u10,mt10_25, mt25_u50, mt50_u75, mt75), length))
#pad vectors
length(complete) <- length(u10)<- length(mt10_25)<- length(mt25_u50)<- length(mt50_u75)<- length(mt75) <- ML
#bind
missingness_groups <- cbind(complete, u10,mt10_25, mt25_u50, mt50_u75, mt75)
output <- list(dimensions = data.frame(nrow = c(original = original_nrow , adjusted = updated_nrow),
ncol = c(original = original_ncol , adjusted = updated_ncol)),
memory_size = memory_size,
data_type_conversion = data_types,
data_type_names = dt_type_frame,
missingness_percentage = missingness_vector,
grouped_missingness = missingness_groups,
data = updated_data$data
)
class(output) <- 'data_describe'
return(output)
}
#' @export
print.data_describe <- function(x){
x <- unclass(x)
pander(x$dimensions)
output_dt_type <- x$data_type_names
output_dt_type[is.na(output_dt_type)] <- ""
pander(output_dt_type)
pander(x$grouped_missingness)
}
Data_Describe(basic_test_data)
#' @export
print.data_describe <- function(x){
x <- unclass(x)
pander(x$dimensions)
output_dt_type <- x$data_type_names
output_dt_type[is.na(output_dt_type)] <- ""
pander(output_dt_type)
output_dt_mis <- x$grouped_missingness
output_dt_mis[is.na(output_dt_mis)] <- ""
pander(output_dt_mis)
}
Data_Describe(basic_test_data)
#number of identicle rows
?dplyr
library(dplyr)
